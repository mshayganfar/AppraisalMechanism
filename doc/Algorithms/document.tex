%%This is a very basic article template.
%%There is just one section and two subsections.
\documentclass{article}

\usepackage[noend]{algpseudocode}
\usepackage{algorithm}

\usepackage{tikz}
\usetikzlibrary{arrows,positioning,automata}

\usepackage{mathrsfs}

\begin{document}

\newcommand{\And}{\textit{\textbf{\footnotesize{ AND }}}}
\newcommand{\Or}{\textit{\textbf{\footnotesize{ OR }}}}
\renewcommand{\algorithmicforall}{\textbf{for each}}
\newcommand*\rfrac[2]{{}^{#1}\!/_{#2}}
\newcommand{\mathlowercal}[1]{\textit{\scriptsize{#1}}}

\center{\Large{\textbf{Algorithms to Compute Appraisal Variables}}}\\

\begin{algorithm}
	\caption{(Relevance)}
	\label{array-sum}
	\begin{algorithmic}[1]
		\Function{IsEventRelevant}{\textit{Events} $\varepsilon_t$} 
			\Statex
			\State Initialize graph $\mathcal{G}_{t}$ with current mental state
			$\mathcal{S}_{t}$.
			\Statex
			\State $\vec{\mathit{g}}_{t} \gets \Call{extractGoal}{\mathcal{G}_{t}}$
			\Statex
			\State $\mathcal{P}_{t} \gets \Call{extractPaths}{\varepsilon_t,
			\vec{\mathit{g}}_{t}}$
			\Statex
			\If {($\mathcal{P}_{t} = \emptyset$)}
				\State \Return {0}
			\Else
				\State $\mathcal{U}_{t} \gets \Call{getEventUtility}{\varepsilon_t,
				\vec{\mathit{g}}_{t}}$ 
				\If {($ \mathcal{U}_{t} \geq \tau_{e} $)}
				\State \Return {($\mathcal{U}_{t}$)}
				\Else
					\State \Return {0}
				\EndIf
			\EndIf
		\EndFunction
		\State \textbf{end function}
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{(Desirability)}
	\label{array-sum}
	\begin{algorithmic}[1]
		\Function{IsEventDesirable}{\textit{Events} $\varepsilon_t$} 
			\Statex
			\State Initialize graph $\mathcal{G}_{t}$ with current mental state
			$\mathcal{S}_{t}$.
			\Statex
			\State $\vec{\mathit{g}}_{t} \gets \Call{extractGoals}{\mathcal{G}_{t}}$ 
			\Statex
			\If {($topLevelTaskStatus() =$ \small{ACHIEVED})}
				\State \Return 1.0
			\ElsIf {($topLevelTaskStatus() =$ \small{BLOCKED})}
				\State \Return -1.0
			\ElsIf {($topLevelTaskStatus() =$ \small{INPROGRESS})}
				\If {($currentTaskStatus() =$ ACHIEVED)}
					\State \Return 0.75
				\ElsIf {($currentTaskStatus() =$ BLOCKED)}
					\State \Return -0.75
				\ElsIf {($currentTaskStatus() =$ INPROGRESS)}
					\State \Return 0.25
				\ElsIf {($currentTaskStatus() =$ UNKNOWN)}
					\If {($taskPreconditionStatus() =$ SATISFIED)}
						\State \Return 0.5
					\ElsIf {($taskPreconditionStatus() =$ UNSATISFIED)}
						\State \Return -0.75
					\ElsIf {($taskPreconditionStatus() =$ UNKNOWN)}
						\If {($doesContribute(\varepsilon_t, \vec{\mathit{g}}_{t}) =$ TRUE)}
							\State \Return -0.5
						\ElsIf {($doesContribute(\varepsilon_t, \vec{\mathit{g}}_{t}) =$ FALSE)}
							\If {($recipeApplicability(\varepsilon_t, \vec{\mathit{g}}_{t}) =$
							\small{APPLICABLE})} \State \Return -0.5
							\ElsIf {($recipeApplicability(\varepsilon_t, \vec{\mathit{g}}_{t}) =$
							\small{INAPPLICABLE})}
								\State \Return -0.75
							\ElsIf {($recipeApplicability(\varepsilon_t, \vec{\mathit{g}}_{t}) =$
							UNKNOWN)}
								\State \Return -0.25
							\EndIf
						\EndIf
					\EndIf
				\EndIf
			\EndIf
		\EndFunction
		\State \textbf{end function}
	\end{algorithmic}
\end{algorithm}

\pagebreak

\begin{algorithm}
	\caption{(Expectedness)}
	\label{array-sum}
	\begin{algorithmic}[1]
		\Function{IsEventExpected}{\textit{Events} $\varepsilon_t$} 
			\Statex
			\State Initialize graph $\mathcal{G}_{t-1}$ with previous mental state
			$\mathcal{S}_{t-1}$.
			\State Initialize graph $\mathcal{G}_{t}$ with current mental state
			$\mathcal{S}_{t}$.
			\Statex
			\State $\vec{\mathit{g}}_{t-1} \gets \Call{extractGoals}{\mathcal{G}_{t-1}}$
			\State $\vec{\mathit{g}}_{t} \gets \Call{extractGoals}{\mathcal{G}_{t}}$
			\Statex
			\If {$(\vec{\mathit{g}}_{t} \neq \vec{\mathit{g}}_{t-1})$}
				\If {$(\Call{IsAchieved}{\vec{\mathit{g}}_{t-1}})$}
					\State $\mathcal{P}_{t} \gets \Call{extractPaths}{\varepsilon_t,
					\vec{\mathit{g}}_{t}}$
					\If {($\mathcal{P}_{t} = \emptyset$)}
						\State \Return FALSE
					\Else
						\State $\mathcal{U}_{t} \gets
						\Call{getPathUtility}{\mathcal{G}_{t}, \vec{\mathit{g}}_{t}}$
						\State $\mathcal{U}_{t-1} \gets \Call{getPathUtility}{\mathcal{G}_{t},
						\vec{\mathit{g}}_{t-1}}$
						\If {$(\mathcal{U}_{t} - \mathcal{U}_{t-1}) \geq \tau_{e}$}
							\State \Return TRUE
						\Else
							\State \Return FALSE
						\EndIf
					\EndIf
				\Else \Comment {Collaboration goal has achieved.}
					\State \Return TRUE
				\EndIf
			\Else \Comment {Goals have not changed.}
				\State \Return TRUE
			\EndIf
		\EndFunction
		\State \textbf{end function}
	\end{algorithmic}
\end{algorithm}

\pagebreak

\begin{algorithm}
	\caption{(Controllability)}
	\label{array-sum}
	\begin{algorithmic}[1]
		\Function{IsEventControllable}{\textit{Events} $\varepsilon_t$}
			\Statex
			\State $\alpha_{self/other}^{^{agency}} \gets
			\beta_{self/other}^{^{autonomy}} \gets 0$
			\Statex
			\State $\lambda_{succeeded/failed}^{^{predecessors}} \gets
			\mu_{available/required}^{^{inputs}} \gets 0$
			\Statex
			\State Initialize graph $\mathcal{G}_{t}$ with current mental state
			$\mathcal{S}_{t}$.
			\Statex
			\State $\vec{\mathit{g}}_{t} \gets \Call{extractGoals}{\mathcal{G}_{t}}$ 
			\State $\mathcal{P}_{\vec{\mathit{g}}_{t}} \gets
			\Call{extractPaths}{\varepsilon_t, \vec{\mathit{g}}_{t}}$
			\Statex
			\State $\alpha_{self/other}^{^{agency}} \gets
			\Call{GetAgencyValue}{\mathcal{P}_{\vec{\mathit{g}}_{t}}}$ 
			\Statex
			\State $\beta_{self/other}^{^{autonomy}} \gets
			\Call{GetAutonomyValue}{\mathcal{P}_{\vec{\mathit{g}}_{t}}}$
			\Statex
			\State $\lambda_{succeeded/total}^{^{predecessors}} \gets
			\Call{GetSucceededPredecessorsRatio}{\mathcal{P}_{\vec{\mathit{g}}_{t}}}$
			\Statex
			\State $\mu_{available/required}^{^{inputs}} \gets
			\Call{GetAvailableInputRatio}{\mathcal{P}_{\vec{\mathit{g}}_{t}}}$
			\State $\mathcal{U}_{t} \gets
			\frac{\omega_{0}\cdot \alpha_{self/other}^{^{agency}} +
			\omega_{1}\cdot \beta_{self/other}^{^{autonomy}} + \omega_{2}\cdot
			\lambda_{succeeded/total}^{^{predecessors}} + \omega_{3}\cdot
			\mu_{available/required}^{^{inputs}}}{\omega_{0} + \omega_{1} + \omega_{2} +
			\omega_{3}}$
			\Statex
			\If {($\mathcal{U}_{t} \geq \tau_e$)}
				\State \Return {TRUE}
			\Else
				\State \Return {FALSE}
			\EndIf
		\EndFunction
		\State \textbf{end function}
		\end{algorithmic}
	\end{algorithm}
	
\pagebreak
	
\begin{algorithm}
	\caption{(Check Predecessors)}
	\label{array-sum}
	\begin{algorithmic}[1]
		\Function{GetSucceededPredecessorsRatio}{\textit{Paths}
		$\mathcal{P}_{\vec{\mathit{g}}}^A$}
			\Statex
			\State $count_{predecessor}^{^{succeeded}} \gets
			count_{predecessor}^{^{total}} \gets 0$
			\Statex
			\State $\Phi_{\vec{\mathit{g}}} \gets
			\Call{extractPredecessors}{\mathcal{P}_{\vec{\mathit{g}}}^{A}}$
			\Statex
			\ForAll {$\phi_{\vec{\mathit{g}}}^i \in \Phi_{\vec{\mathit{g}}}$}
				\If {($\Call{IsSucceeded}{\phi_{\vec{\mathit{g}}}^i}$)}
					\State $count_{predecessor}^{^{succeeded}} \gets count_{predecessor}^{^{succeeded}} + 1$
				\EndIf
				\State $count_{predecessor}^{^{total}} \gets count_{predecessor}^{^{total}} + 1$
			\EndFor
			\Statex
			\State \Return {$\langle count_{predecessor}^{^{succeeded}},
			count_{predecessor}^{^{total}}\rangle$}
		\EndFunction 
	\State \textbf{end function}
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{(Check Inputs)}
	\label{array-sum}
	\begin{algorithmic}[1]
		\Function{GetAvailableInputRatio}{\textit{Paths}
		$\mathcal{P}_{\vec{\mathit{g}}}^A$}
			\Statex
			\State $count_{input}^{^{available}} \gets count_{input}^{^{required}} \gets
			0$
			\Statex
			\State $\mathcal{X}_{\vec{\mathit{g}}} \gets
			\Call{extractInputs}{\mathcal{P}_{\vec{\mathit{g}}}^{A}}$
			\Statex
			\ForAll {$\chi_{\vec{\mathit{g}}}^i \in \mathcal{X}_{\vec{\mathit{g}}}$}
				\If {($\Call{IsSucceeded}{\chi_{\vec{\mathit{g}}}^i}$)}
					\State $count_{input}^{^{available}} \gets count_{input}^{^{available}} + 1$
				\EndIf
				\State $count_{input}^{^{required}} \gets count_{input}^{^{required}} + 1$
			\EndFor
			\Statex
			\State \Return {$\langle count_{input}^{^{available}},
			count_{input}^{^{required}}\rangle$}
		\EndFunction 
	\State \textbf{end function}
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{(Get Agency Value)}
	\label{array-sum}
	\begin{algorithmic}[1]
		\Function{GetAgencyValue}{\textit{Paths}
		$\mathcal{P}_{\vec{\mathit{g}}}^{A}$}
			\Statex
			\State $count_{responsibility}^{^{self}} \gets
			count_{responsibility}^{^{other}} \gets 0$
			\Statex
			\State $\Theta_{\vec{\mathit{g}}} \gets
			\Call{ExtractPreconditions}{\mathcal{P}_{\vec{\mathit{g}}}^{A}}$
			\Statex
			\ForAll {$\theta_{\vec{\mathit{g}}}^i \in \Theta_{\vec{\mathit{g}}}$}
				\If {($\Call{GetResponsible}{\theta_{\vec{\mathit{g}}}^i} =$ SELF)}
					\State $count_{responsibility}^{^{self}} \gets count_{responsibility}^{^{self}} + 1$
				\Else
					\State $count_{responsibility}^{^{other}} \gets
				count_{responsibility}^{^{other}} + 1$
				\EndIf
			\EndFor
			\Statex
			\State \Return {$\langle count_{responsibility}^{^{self}},
			count_{responsibility}^{^{other}}\rangle$}
		\EndFunction 
	\State \textbf{end function}
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{(Get Autonomy Value)}
	\label{array-sum}
	\begin{algorithmic}[1]
		\Function{GetAutonomyValue}{\textit{Paths}
		$\mathcal{P}_{\vec{\mathit{g}}}^{A}$}
			\Statex
			\State $\mathcal{A} \gets
			\Call{ExtractAction}{\mathcal{P}_{\vec{\mathit{g}}}^{A}}$ 
			\State $\mathcal{R}_{\mathcal{A}} \gets \Call{GetResponsible}{\mathcal{A}}$
			\State $\mathcal{M}_{\mathcal{R}_{\mathcal{A}}} \gets
			\Call{GetMotive}{\mathcal{R}_{\mathcal{A}}}$
			\Statex
			\If {($\mathcal{M}_{\mathcal{R}_{\mathcal{A}}} \neq \emptyset$)}
				\State \Return {MAX}
			\Else
				\State \Return {MIN}
			\EndIf
		\EndFunction 
	\State \textbf{end function}
	\end{algorithmic}
\end{algorithm}

\end{document}
